==client==
fill info
connect
send name
while stay
	recv object
	while 1	
		getHangTime
		select (with timeout)
		if server message then
			recv
		if timeout
			send prix_prop
			recv
			if accepted then
				lastBid = vrai
				continue
		if end object then break
		if end then
			stay = faux
			break
		if new price
			update info
			lastBid = faux
	if lastBid then
		lastBid = faux
		get object
close

==server==
init
fill objects
create pool
create auctioneer
create sock ecoute
while 1
	update sock set
	select
	if sock master
		accept connexion
		wait semWork
		find free worker
		set canal
		post to his sem
	if IO
		clientMessage = vrai
		find which sock
		post to his sem
		

==worker==
while 1
	wait data->sem
	data->libre = faux
	recv infos
	update clients tab (join)
	wait data->sem (wait 1st obj auction)
	while stay
		wait barrier
		send object infos
		while 1
			wait data->sem
			lock bid
			if end then (woke by auctioneer)
				send end
				stay = faux
				break
			if end object then (woke by auctioneer)
				send end object
				break
			if bid != lastPrice then (woke by auctioneer)
				lastPrice = bid
				send new price
			if client message then (woke by server)
				clientMessage = faux
				recv
				if new bid then
					if bid == prix_connu && prix_prop > bid then
						bid = lastPrice = prix_prop
						bidder = data->tid
						send accepted
						wake auctioneer (signal cond bid)
			unlock bid
		unlock bid
	close
	data->libre = vrai
	post data->sem


==auctioneer==
wait 1 min
set lastBidder tab = -1
init barrier
for i = each object
	wakeClients
	set object
	bid = curObj->prix_cur = curObj->prix_ini
	wait barrier
	lock bid
	end object = faux
	while 1
		cond wait bid (with timeout)
		if signaled then
			curObj->prix_cur = bid
			lastBidder[i] = bidder
		if timeout then
			sell object to lastBidder[i]
			end object = vrai
			break
		wakeClients
end = vrai
wakeClients



